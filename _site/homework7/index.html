<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="/assets/css/custom.css">
    <!-- start custom head snippets, customize with your own _includes/head-custom.html file -->

<!-- Setup theme-color -->
<!-- start theme color meta headers -->
<meta name="theme-color" content="#151515">
<meta name="msapplication-navbutton-color" content="#151515">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<!-- end theme color meta headers -->


<!-- Setup Google Analytics -->



<!-- You can set your favicon here -->
<!-- link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" -->

<!-- end custom head snippets -->


<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Homework 7 | Simone’s Statistics Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Homework 7" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/homework7/" />
<meta property="og:url" content="http://localhost:4000/homework7/" />
<meta property="og:site_name" content="Simone’s Statistics Blog" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Homework 7" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","headline":"Homework 7","url":"http://localhost:4000/homework7/"}</script>
<!-- End Jekyll SEO tag -->

  </head>

  <body>

    <header>
      <div class="container">
        <a id="a-title" href="/">
          <h1>Simone's Statistics Blog</h1>
        </a>
        <h2></h2>

        <section id="downloads">
          
          <a href="https://github.com/simonedigregorio11/simonedigregorio11.github.io" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
          <nav style="background: url('/assets/images/bkg.png'); padding-bottom: 20px; font-family: sans-serif;">
            <ul class="navbar" style="list-style: none; margin: 0; padding: 0; display: flex; align-items: center;">
              <li><a href="/" style="color: #63c0f5; text-decoration: none; font-size: 25px;">Home</a></li>

              <li style="position: relative;">
                <a href="#" style="color: #63c0f5; text-decoration: none; font-size: 25px; ">Homework ▾</a>
                <ul style="
                  display: none;
                  position: absolute;
                  background-color: #333;
                  list-style: none;
                  padding: 10px;
                  margin: 0;
                  border-radius: 6px;
                  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
                ">
                  <li><a href="/homework1/" style="color: #63c0f5; text-decoration: none; display: block; padding: 5px 10px; font-size: 18px">Homework 1</a></li>
                  <li><a href="/homework2/" style="color: #63c0f5; text-decoration: none; display: block; padding: 5px 10px; font-size: 18px">Homework 2</a></li>
                  <li><a href="/homework3/" style="color: #63c0f5; text-decoration: none; display: block; padding: 5px 10px; font-size: 18px">Homework 3</a></li>
                  <li><a href="/homework4/" style="color: #63c0f5; text-decoration: none; display: block; padding: 5px 10px; font-size: 18px">Homework 4</a></li>
                  <li><a href="/homework5/" style="color: #63c0f5; text-decoration: none; display: block; padding: 5px 10px; font-size: 18px">Homework 5</a></li>
                  <li><a href="/homework6/" style="color: #63c0f5; text-decoration: none; display: block; padding: 5px 10px; font-size: 18px">Homework 6</a></li>
                  <li><a href="/homework7/" style="color: #63c0f5; text-decoration: none; display: block; padding: 5px 10px; font-size: 18px">Homework 7</a></li>
                  <li><a href="/homework8/" style="color: #63c0f5; text-decoration: none; display: block; padding: 5px 10px; font-size: 18px">Homework 8</a></li>
                  <li><a href="/homework9/" style="color: #63c0f5; text-decoration: none; display: block; padding: 5px 10px; font-size: 18px">Homework 9</a></li>
                  <li><a href="/homework10/" style="color: #63c0f5; text-decoration: none; display: block; padding: 5px 10px; font-size: 18px">Homework 10</a></li>
                
                </ul>
              </li>

              <li><a href="/about/" style="color: #63c0f5; text-decoration: none; font-size: 25px;">About</a></li>
            </ul>
          </nav>

          <script>
            document.querySelectorAll("nav li").forEach(li => {
              li.addEventListener("mouseenter", () => {
                const submenu = li.querySelector("ul");
                if (submenu) submenu.style.display = "block";
              });
              li.addEventListener("mouseleave", () => {
                const submenu = li.querySelector("ul");
                if (submenu) submenu.style.display = "none";
              });
            });
          </script>
        <link rel="stylesheet" href="/assets/css/pages/homework7.css" />

<p><a href="/">← Back to Home</a></p>

<hr />

<h1 id="random-walk-and-binomial-convergence"><strong>Random Walk and Binomial Convergence</strong></h1>

<h2 id="introduction"><strong>Introduction</strong></h2>

<p>This assignment investigates a probabilistic model for a <strong>server that receives weekly security updates</strong> while being
targeted by multiple independent attackers. Each week, every attacker has a probability <strong>p</strong> of successfully breaching
the system. If <strong>m</strong> attackers are active, the probability that the system suffers <em>any</em> breach in a week becomes</p>

<div class="formula-box">
    q = 1 - (1 - p)<sup>m</sup>
</div>

<p>The server’s “security score” S<sub>t</sub> evolves over <strong>n weeks</strong> as a <strong>random walk</strong> taking steps:</p>

<div class="formula-box">
    <div class="formula">
        X<sub>t</sub> =
        <span class="cases">
            <span class="cases-row">+1  if the server remains secure</span>
            <span class="cases-row">−1  if the server is breached</span>
        </span>
    </div><br />
    so that <strong>S<sub>t</sub> = Σ<sub>i=1</sub><sup>t</sup> X<sub>i</sub></strong>
</div>

<p>The cumulative endpoint <strong>S<sub>n</sub></strong> can take values in {n, n-2, …, -n}.
Since breaches are independent, the probability of k breaches follows a <strong>Binomial(n, q)</strong> distribution, which—after
mapping S<sub>n</sub> = n - 2k describes the theoretical law of the random walk endpoints.
By simulating many independent runs, we can observe how the empirical distribution of S<sub>n</sub> converges to this
theoretical model as <strong>n</strong> and <strong>R</strong> grow.</p>

<hr />

<h2 id="objectives"><strong>Objectives</strong></h2>

<ul>
  <li>
    <p>Simulate R independent trajectories of length n.</p>
  </li>
  <li>
    <p>Visualize these as <strong>random-walk paths</strong> showing the drift E[S<sub>t</sub>] = t(1−2q).</p>
  </li>
  <li>
    <p>Count how many trajectories end at each possible S<sub>n</sub>.</p>
  </li>
  <li>
    <p>Compare the empirical frequencies to the <strong>Binomial(n, q)</strong> distribution.</p>
  </li>
  <li>
    <p>Evaluate convergence numerically through <strong>total variation distance</strong>.</p>
  </li>
</ul>

<hr />

<h2 id="the-interactive-tool"><strong>The Interactive Tool</strong></h2>

<p>The implemented web tool provides:<br /></p>

<ul>
  <li>
    <p>Numeric inputs for <em>n</em>, <em>m</em>, <em>p</em>, <em>R</em>, and batch size.</p>
  </li>
  <li>
    <p>Real-time plotting of <strong>trajectories</strong> (left panel) and <strong>endpoint distribution</strong> (right panel).</p>
  </li>
  <li>
    <p>An animated accumulation process that shows convergence toward the theoretical curve.</p>
  </li>
  <li>
    <p>A data table displaying counts, empirical frequencies, and theoretical probabilities.</p>
  </li>
  <li>
    <p>Computed metrics: empirical mean/variance vs theoretical mean/variance, and total variation distance.</p>
  </li>
</ul>

<hr />

<h1 id="demo"><strong>Demo</strong></h1>

<div class="hw7">
    <div class="card">
        <div class="row">
            <label>Weeks n</label><input id="n" type="number" min="1" value="80" />
            <label>Attackers m</label><input id="m" type="number" min="1" value="5" />
            <label>p (per attacker)</label><input id="p" type="number" min="0" max="1" step="0.01" value="0.30" />
            <label>Runs R</label><input id="R" type="number" min="1" value="6000" />
            <label>Batch size</label><input id="batch" type="number" min="1" value="500" />
            <label>Paths shown</label><input id="keep" type="number" min="0" value="400" title="How many trajectories to draw (for speed)" />
        </div>
        <div class="buttons">
            <button id="run">Run</button>
            <button class="danger" id="clear">Clear</button>
        </div>
        <div class="stats-container" id="statscontainer">
            <div class="stats" id="paramline"></div>
            <div class="stats" id="statline"></div>
        </div>
    </div>

    <div class="grid">
        <div class="card">
            <h3 style="margin:0 0 8px;">Random-Walk Trajectories</h3>
            <div class="legend">
                Parallel with a (possibly biased) ±1 random walk. Drift = E[X] = 1 − 2q.<br />
                Here p is per attacker and q = 1 − (1 − p)<sup>m</sup> is the weekly breach probability.
            </div>

            <div class="hr"></div>
            <canvas id="paths" width="1200" height="300" aria-label="Random-walk trajectories"></canvas>
        </div>

        <div class="card">
            <h3 style="margin:0 0 8px;">Endpoint Distribution at t = n</h3>
            <div class="legend">
                Bars = empirical counts/R for S<sub>n</sub> ∈ {n, n−2, …, −n}. Green line = Binomial(n,q) mapped via
                S<sub>n</sub> = n − 2k.
            </div>
            <div class="hr"></div>
            <canvas id="hist" width="1200" height="300" aria-label="Endpoint histogram"></canvas>
            <div id="tableWrap" class="legend" style="margin-top:8px">Run to view counts.</div>
        </div>
    </div>
    <script>
        /* =========================
           HiDPI-safe canvas prep
           ========================= */
        /* Returns a 2D context scaled so that 1 unit in canvas commands = 1 CSS pixel. */
        /* Global canvas-size lock to keep width/height stable while the run is animating */
        let CANVAS_LOCK = null; // {paths:{w,h}, hist:{w,h}} or null
        let RUN_ID = 0;

        function prepCanvas(canvas, key) {
            const dpr = window.devicePixelRatio || 1;

            // If a run is in progress, reuse the locked CSS size to avoid reflow-induced resizes
            let cssW, cssH;
            if (CANVAS_LOCK && CANVAS_LOCK[key]) {
                ({ w: cssW, h: cssH } = CANVAS_LOCK[key]);
            } else {
                const rect = canvas.getBoundingClientRect();
                cssW = Math.max(1, rect.width);
                cssH = Math.max(1, rect.height);
            }

            // Desired backing-store size (integer, HiDPI aware)
            const bw = Math.max(1, Math.floor(cssW * dpr));
            const bh = Math.max(1, Math.floor(cssH * dpr));

            // Update only when it actually changes (prevents context reset)
            if (canvas.width !== bw || canvas.height !== bh) {
                canvas.width = bw;
                canvas.height = bh;
            }

            const ctx = canvas.getContext('2d');
            // Set transform so that 1 canvas unit = 1 CSS pixel (guarded to avoid redundant work)
            const t = ctx.getTransform();
            if (t.a !== dpr || t.d !== dpr || t.b !== 0 || t.c !== 0 || t.e !== 0 || t.f !== 0) {
                ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            return { cssW, cssH, ctx };
        }


        /* =========================
           Math helpers & utilities
           ========================= */
        const clamp = (x, a, b) => Math.max(a, Math.min(b, x));

        /* Binomial coefficient C(n,k) via multiplicative formula (stable for moderate n) */
        function binom(n, k) {
            if (k < 0 || k > n) return 0;
            if (k === 0 || k === n) return 1;
            k = Math.min(k, n - k);
            let c = 1;
            for (let i = 1; i <= k; i++) c = (c * (n - k + i)) / i;
            return c;
        }

        /* Binomial PMF for K~Bin(n,q); returns Float64Array of length n+1 */
        function binomialPMF(n, q) {
            const pmf = new Float64Array(n + 1);
            for (let k = 0; k <= n; k++) pmf[k] = binom(n, k) * Math.pow(q, k) * Math.pow(1 - q, n - k);
            return pmf;
        }

        /* "Nice" linear ticks between min and max, aiming for ~targetCount labels */
        function niceTicks(min, max, targetCount = 6) {
            if (!isFinite(min) || !isFinite(max) || min === max) {
                const v = isFinite(min) ? min : 0;
                return [v - 1, v, v + 1];
            }
            const span = max - min;
            const raw = span / Math.max(1, targetCount);
            const pow10 = Math.pow(10, Math.floor(Math.log10(raw)));
            const candidates = [1, 2, 2.5, 5, 10].map(m => m * pow10);
            const step = candidates.reduce((best, c) => Math.abs(c - raw) < Math.abs(best - raw) ? c : best, candidates[0]);
            const niceMin = Math.floor(min / step) * step;
            const niceMax = Math.ceil(max / step) * step;
            const ticks = [];
            for (let v = niceMin; v <= niceMax + 1e-12; v += step) {
                const vv = Math.abs(v) < 1e-12 ? 0 : +v.toPrecision(12); // trim fp noise
                ticks.push(vv);
            }
            return ticks;
        }

        /* =========================
           Simulation
           ========================= */
        /* Simulates R walks of length n with step +1 (no breach) w.p. (1-q) and -1 (breach) w.p. q.
           Returns Map of endpoints and up to 'keep' full paths for drawing. */
        function simulate(n, R, q, keep = 400) {
            const kept = Math.min(R, keep);
            const paths = new Array(kept);
            for (let i = 0; i < kept; i++) paths[i] = new Int16Array(n + 1);

            const endpoints = new Map(); // key = S_n ∈ {-n,-n+2,...,n}
            for (let r = 0; r < R; r++) {
                let s = 0;
                const store = (r < kept);
                if (store) paths[r][0] = 0;
                for (let t = 1; t <= n; t++) {
                    s += (Math.random() < q) ? -1 : 1;  // −1 if breach, +1 otherwise
                    if (store) paths[r][t] = s;
                }
                endpoints.set(s, (endpoints.get(s) || 0) + 1);
            }
            return { paths: kept ? paths : [], endpoints };
        }

        /* =========================
           Drawing: trajectories with axes, ticks, grid (CLIPPED)
           ========================= */
        function drawPaths(paths, canvas) {
            const { cssW, cssH, ctx } = prepCanvas(canvas, "paths");
            ctx.clearRect(0, 0, cssW, cssH);
            if (!paths.length) return;

            const n = paths[0].length - 1;
            const padL = 60, padB = 34, padT = 14, padR = 16;
            const W = cssW - padL - padR;
            const H = cssH - padT - padB;
            const x0 = padL, y0 = cssH - padB;

            // Global min/max across all paths (for vertical scale)
            let gmin = 0, gmax = 0;
            for (const p of paths) {
                for (let t = 0; t <= n; t++) { gmin = Math.min(gmin, p[t]); gmax = Math.max(gmax, p[t]); }
            }
            if (gmin === gmax) { gmin--; gmax++; }

            const sx = W / n;
            const sy = H / (gmax - gmin);

            // Axes
            ctx.strokeStyle = "#e2e8f0"; ctx.lineWidth = 1;
            // x-axis
            ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x0 + W, y0); ctx.stroke();
            // y-axis
            ctx.beginPath(); ctx.moveTo(x0, y0 - H); ctx.lineTo(x0, y0); ctx.stroke();

            // X ticks (time t), aim for ~10 labels
            ctx.fillStyle = "#e2e8f0"; ctx.font = "12px system-ui, Monaco, monospace";
            ctx.textAlign = "center"; ctx.textBaseline = "top";
            const xStep = Math.max(1, Math.round(n / 10));
            for (let t = 0; t <= n; t += xStep) {
                const x = x0 + t * sx;
                ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y0 + 4); ctx.stroke();
                ctx.fillText(String(t), x, y0 + 6);
            }

            // Y ticks (S_t) with light horizontal grid — labels kept inside the frame
            {
                const yTicks = niceTicks(gmin, gmax, 6).filter(v => v >= gmin - 1e-9 && v <= gmax + 1e-9);
                const yTop = y0 - H, yBot = y0;

                ctx.textAlign = "right";
                ctx.font = "12px system-ui, Monaco, monospace";

                for (const v of yTicks) {
                    const yRaw = y0 - (v - gmin) * sy;
                    // Clamp grid/tick to the plotting area
                    const yGrid = Math.max(yTop, Math.min(yBot, yRaw));

                    // grid line
                    ctx.strokeStyle = "rgba(226,232,240,.25)";
                    ctx.lineWidth = 1;
                    ctx.beginPath(); ctx.moveTo(x0, yGrid); ctx.lineTo(x0 + W, yGrid); ctx.stroke();

                    // tick mark
                    ctx.strokeStyle = "#e2e8f0";
                    ctx.beginPath(); ctx.moveTo(x0 - 4, yGrid); ctx.lineTo(x0, yGrid); ctx.stroke();

                    // label: nudge inside if we’re on the very top/bottom edge
                    let yLabel = yGrid;
                    if (Math.abs(yGrid - yBot) < 0.75) { // bottom edge
                        ctx.textBaseline = "bottom";
                        yLabel = yBot - 2;
                    } else if (Math.abs(yGrid - yTop) < 0.75) { // top edge
                        ctx.textBaseline = "top";
                        yLabel = yTop + 2;
                    } else {
                        ctx.textBaseline = "middle";
                    }

                    const lab = Math.abs(v) < 1e-9 ? "0" : v.toFixed(0);
                    ctx.fillStyle = "#e2e8f0";
                    ctx.fillText(lab, x0 - 6, yLabel);
                }
            }

            // ---- CLIP: keep strokes strictly inside the plotting area ----
            ctx.save();
            // Exact plot rectangle (no half-pixel inset; avoids right-edge overflow when sx is fractional)
            ctx.beginPath();
            ctx.rect(x0, y0 - H, W, H);
            ctx.clip();

            // Paths (clipped)
            const xMax = x0 + W; // used for a gentle clamp to avoid anti-aliased bleed at the right edge
            for (const p of paths) {
                const grad = ctx.createLinearGradient(x0, 0, x0 + W, 0);
                grad.addColorStop(0, 'white'); grad.addColorStop(1, '#b5e853');
                ctx.strokeStyle = grad; ctx.lineWidth = 0.8; ctx.globalAlpha = 0.8;
                ctx.lineCap = "butt"; ctx.lineJoin = "miter";
                ctx.beginPath();
                for (let t = 0; t <= n; t++) {
                    // Clamp x by a tiny epsilon inside the frame to ensure last vertex never spills outside
                    const x = Math.min(xMax - 0.5, x0 + t * sx);
                    const y = y0 - (p[t] - gmin) * sy;
                    if (t === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();
            // ------------------------------------------------------

            // Thin frame to visually seal the plot area
            ctx.strokeStyle = "rgba(226,232,240,.6)";
            ctx.lineWidth = 1;
            // Align to pixel grid for crispness
            ctx.strokeRect(Math.round(x0) + 0.5, Math.round(y0 - H) + 0.5, Math.round(W) - 1, Math.round(H) - 1);

            // Tiny axis titles
            ctx.fillStyle = "#e2e8f0"; ctx.font = "12px system-ui, Monaco, monospace";
            ctx.textAlign = "left"; ctx.textBaseline = "alphabetic";
            ctx.fillText("t", x0 + W, y0 + 28);
            ctx.save();
            ctx.translate(x0 - 36, y0 - H + 20);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText("S_t", 0, 0);
            ctx.restore();
        }


        /* =========================
           Drawing: histogram + theory with axes, ticks, grid
           ========================= */
        function drawHistogram(endpoints, n, R, pmf, canvas) {
            const { cssW, cssH, ctx } = prepCanvas(canvas, "hist");
            ctx.clearRect(0, 0, cssW, cssH);

            const padL = 60, padB = 34, padT = 14, padR = 16;
            const W = cssW - padL - padR;
            const H = cssH - padT - padB;
            const x0 = padL, y0 = cssH - padB;

            // Possible S_n values
            const scores = [];
            for (let s = -n; s <= n; s += 2) scores.push(s);

            // X scaling for discrete bars
            const barW = Math.max(2, Math.min(26, W / (scores.length + 2)));
            const xOf = s => x0 + ((s + n) / 2 + 1) * barW;

            // Max empirical frequency (for y scaling)
            let maxF = 0;
            for (const s of scores) {
                const f = (endpoints.get(s) || 0) / R;
                if (f > maxF) maxF = f;
            }
            if (maxF < 1e-12) maxF = 1;
            const yOfFreq = f => y0 - f * (H * 0.95 / maxF);

            // Axes
            ctx.strokeStyle = "#e2e8f0"; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(x0, y0); ctx.lineTo(x0 + W, y0); ctx.stroke(); // x-axis
            ctx.beginPath(); ctx.moveTo(x0, y0 - H); ctx.lineTo(x0, y0); ctx.stroke(); // y-axis

            // X ticks (s = n-2k)
            ctx.fillStyle = "#e2e8f0"; ctx.font = "12px system-ui, Monaco, monospace";
            ctx.textAlign = "center"; ctx.textBaseline = "top";
            const stepS = Math.max(2, Math.floor(n / 10) * 2);
            for (let s = -n; s <= n; s += stepS) {
                const x = xOf(s);
                ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y0 + 4); ctx.stroke();
                ctx.fillText(String(s), x, y0 + 6);
            }

            // Y ticks (frequencies) with horizontal grid
            const yTicks = niceTicks(0, maxF, 6);
            ctx.textAlign = "right"; ctx.textBaseline = "middle";
            for (const v of yTicks) {
                const y = yOfFreq(v);
                // grid
                ctx.strokeStyle = "rgba(226,232,240,.25)";
                ctx.beginPath(); ctx.moveTo(x0, y); ctx.lineTo(x0 + W, y); ctx.stroke();
                // tick
                ctx.strokeStyle = "#e2e8f0";
                ctx.beginPath(); ctx.moveTo(x0 - 4, y); ctx.lineTo(x0, y); ctx.stroke();
                // label
                const lab = (v >= 0.1 || maxF >= 0.5) ? v.toFixed(1) : v.toFixed(2);
                ctx.fillStyle = "#e2e8f0";
                ctx.fillText(lab, x0 - 6, y);
            }

            // Empirical bars
            ctx.fillStyle = "#ffffff";
            for (const s of scores) {
                const f = (endpoints.get(s) || 0) / R;
                const x = xOf(s), y = yOfFreq(f);
                ctx.fillRect(x - barW * 0.45, y, barW * 0.9, y0 - y);
            }

            // Theoretical polyline (Bin(n,q) mapped via s = n - 2k)
            ctx.strokeStyle = "#b5e853"; ctx.lineWidth = 2;
            ctx.beginPath(); let first = true;
            for (let k = 0; k <= n; k++) {
                const s = n - 2 * k;
                const prob = pmf[k];
                const x = xOf(s), y = yOfFreq(prob);
                if (first) { ctx.moveTo(x, y); first = false; } else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Tiny axis titles
            ctx.fillStyle = "#e2e8f0"; ctx.font = "12px system-ui, Monaco, monospace";
            ctx.textAlign = "left"; ctx.textBaseline = "alphabetic";
            ctx.fillText("S_n", x0 + W - 12, y0 + 28);
            ctx.save();
            ctx.translate(x0 - 36, y0 - H + 55);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText("frequency", 0, 0);
            ctx.restore();
        }

        /* =========================
           Table & convergence metric
           ========================= */
        /* Builds an HTML table mapping k breaches ↔ s = n-2k, with empirical vs theoretical probabilities. */
        function renderTable(endpoints, n, R, pmf) {
            let html = `<table><thead>
    <tr><th>Score s = n − 2k</th><th>k breaches</th><th>Count</th><th>Empirical freq</th><th>Theoretical P</th></tr>
  </thead><tbody>`;
            for (let k = 0; k <= n; k++) {
                const s = n - 2 * k;
                const c = endpoints.get(s) || 0;
                const f = c / R;
                const p = pmf[k];
                html += `<tr><td>${s}</td><td>${k}</td><td>${c}</td><td>${f.toFixed(4)}</td><td>${p.toFixed(4)}</td></tr>`;
            }
            html += `</tbody></table>`;
            document.getElementById('tableWrap').innerHTML = html;
        }

        /* Total variation distance between empirical distribution of S_n and the mapped Binomial(n,q) */
        function totalVariation(endpoints, n, R, pmf) {
            let tv = 0;
            for (let k = 0; k <= n; k++) {
                const s = n - 2 * k;
                const f = (endpoints.get(s) || 0) / R;
                tv += Math.abs(f - pmf[k]);
            }
            return 0.5 * tv;
        }

        /* =========================
           Controller
           ========================= */
        const pathsC = document.getElementById('paths');
        const histC = document.getElementById('hist');

        let lastState = {
            paths: [],
            endpoints: new Map(),
            n: 0, R: 0, pmf: new Float64Array(0),
            q: 0
        };

        function setParamLine(n, m, p, q, R) {
            document.getElementById('paramline').innerHTML =
                `n = <strong>${n}</strong>, m = <strong>${m}</strong>, p = <strong>${p.toFixed(4)}</strong> → q = <strong>${q.toFixed(6)}</strong>, runs = <strong>${R}</strong>`;
        }

        function setStatsLine(n, q, R, endpoints) {
            // Empirical mean/var of S_n; theoretical mean/var for S_n
            let sum = 0, sumsq = 0;
            for (let k = 0; k <= n; k++) {
                const s = n - 2 * k;
                const c = endpoints.get(s) || 0;
                sum += s * c;
                sumsq += s * s * c;
            }
            const meanEmp = R ? sum / R : 0;
            const varEmp = R ? (sumsq / R - meanEmp * meanEmp) : 0;

            const meanTh = n * (1 - 2 * q);
            const varTh = 4 * n * q * (1 - q);

            document.getElementById('statline').innerHTML =
                `Empirical: E[Sn] = <strong>${meanEmp.toFixed(3)}</strong>, Var[Sn] = <strong>${varEmp.toFixed(3)}</strong> | Theoretical: E[Sn] = <strong>${meanTh.toFixed(3)}</strong>, Var[Sn] = <strong>${varTh.toFixed(3)}</strong>`;
        }

        document.getElementById('run').addEventListener('click', async () => {
            const myRun = ++RUN_ID;
            document.getElementById('statscontainer').style.display = 'block';
            const n = clamp(parseInt(document.getElementById('n').value, 10) || 0, 1, 20000);
            const m = clamp(parseInt(document.getElementById('m').value, 10) || 0, 1, 100000);
            const p = clamp(parseFloat(document.getElementById('p').value) || 0, 0, 1);
            const R = clamp(parseInt(document.getElementById('R').value, 10) || 0, 1, 200000);
            const keep = clamp(parseInt(document.getElementById('keep').value, 10) || 0, 0, R);
            const batch = clamp(parseInt(document.getElementById('batch').value, 10) || 500, 1, 10000);

            const q = 1 - Math.pow(1 - p, m); // weekly breach with m independent attackers
            setParamLine(n, m, p, q, R);

            const pmf = binomialPMF(n, q);

            // ===== SIZE LOCK: capture canvas CSS sizes once and keep them stable for the whole run =====
            {
                const r1 = pathsC.getBoundingClientRect();
                const r2 = histC.getBoundingClientRect();
                CANVAS_LOCK = {
                    paths: { w: Math.max(1, r1.width), h: Math.max(1, r1.height) },
                    hist: { w: Math.max(1, r2.width), h: Math.max(1, r2.height) }
                };
            }

            // Animated accumulation by batches: visually shows convergence of the empirical histogram to theory
            let acc = new Map();
            let drawn = [];
            let done = 0;
            try {
                while (done < R) {
                    if (myRun !== RUN_ID) break;
                    const chunk = Math.min(batch, R - done);
                    const { paths, endpoints } = simulate(n, chunk, q, Math.min(keep, 120)); // draw a subset per batch
                    // accumulate endpoints
                    for (const [s, c] of endpoints.entries())
                        acc.set(s, (acc.get(s) || 0) + c);
                    // maintain only last 'keep' paths
                    drawn = drawn.concat(paths).slice(-keep);

                    // redraw with current totals (sizes stay stable thanks to CANVAS_LOCK)
                    drawPaths(drawn, pathsC);
                    drawHistogram(acc, n, done + chunk, pmf, histC);
                    renderTable(acc, n, done + chunk, pmf);
                    setStatsLine(n, q, done + chunk, acc);
                    const tv = totalVariation(acc, n, done + chunk, pmf);
                    document.getElementById('statline').innerHTML +=
                        `Total variation distance = <strong>${tv.toFixed(5)}</strong> (after ${done + chunk})`;

                    // Save current state for resize-safe redraws
                    lastState = { paths: drawn, endpoints: new Map(acc), n, R: done + chunk, pmf, q };

                    // Short pause for animation
                    await new Promise(r => setTimeout(r, 70));
                    done += chunk;
                }
            } finally {
                // ===== UNLOCK at end (even if loop breaks/throws) =====
                CANVAS_LOCK = null;
            }
        });

        document.getElementById('clear').addEventListener('click', () => {
            RUN_ID++;
            document.getElementById('statscontainer').style.display = 'none';
            // Clear canvases
            const { cssW: w1, cssH: h1, ctx: c1 } = prepCanvas(pathsC, "paths");
            c1.clearRect(0, 0, w1, h1);
            const { cssW: w2, cssH: h2, ctx: c2 } = prepCanvas(histC, "hist");
            c2.clearRect(0, 0, w2, h2);
            // Clear text
            document.getElementById('tableWrap').textContent = 'Cleared.';
            document.getElementById('paramline').textContent = '';
            document.getElementById('statline').textContent = '';
            // Reset state
            lastState = { paths: [], endpoints: new Map(), n: 0, R: 0, pmf: new Float64Array(0), q: 0 };
            // Ensure no stale lock remains
            CANVAS_LOCK = null;
        });

        /* =========================
           Redraw on resize
           ========================= */
        /* On resize we redraw. If a run is active, prepCanvas uses the lock so the plot area stays stable. */
        window.addEventListener('resize', () => {
            const { paths, endpoints, n, R, pmf } = lastState || {};
            if (!paths) return;
            if (paths.length) drawPaths(paths, pathsC);
            if (pmf && pmf.length && n > 0) drawHistogram(endpoints, n, R, pmf, histC);
        });
    </script>
</div>

<hr />

<h2 id="code-screenshot"><strong>Code Screenshot</strong></h2>

<p><img src="/assets/images/code_5.png" alt="code" /></p>

<hr />

<h2 id="code-analysis"><strong>Code Analysis</strong></h2>

<p>Below are the key sections of the code, presented completely and explained line by line.</p>

<h3 id="a-probability-setup"><strong>a. Probability Setup</strong></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">q</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">m</span><span class="p">);</span> <span class="c1">// weekly breach probability from m independent attackers</span>
<span class="nx">setParamLine</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">m</span><span class="p">,</span> <span class="nx">p</span><span class="p">,</span> <span class="nx">q</span><span class="p">,</span> <span class="nx">R</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>Explanation</strong><br />
This converts the <strong>per-attacker breach probability p</strong> into the <strong>weekly probability q</strong> that at least one attacker succeeds.
It is later used both for generating the random walks and computing the theoretical Binomial distribution.</p>

<h3 id="b-simulation-core"><strong>b. Simulation Core</strong></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">simulate</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">R</span><span class="p">,</span> <span class="nx">q</span><span class="p">,</span> <span class="nx">keep</span> <span class="o">=</span> <span class="mi">400</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">kept</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">R</span><span class="p">,</span> <span class="nx">keep</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">paths</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">kept</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">kept</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">paths</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Int16Array</span><span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">endpoints</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span> <span class="c1">// key = S_n ∈ {-n, -n+2, ..., n}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">r</span> <span class="o">&lt;</span> <span class="nx">R</span><span class="p">;</span> <span class="nx">r</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="p">(</span><span class="nx">r</span> <span class="o">&lt;</span> <span class="nx">kept</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">store</span><span class="p">)</span> <span class="nx">paths</span><span class="p">[</span><span class="nx">r</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">t</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">s</span> <span class="o">+=</span> <span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="nx">q</span><span class="p">)</span> <span class="p">?</span> <span class="o">-</span><span class="mi">1</span> <span class="p">:</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// breach → -1, secure → +1</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">store</span><span class="p">)</span> <span class="nx">paths</span><span class="p">[</span><span class="nx">r</span><span class="p">][</span><span class="nx">t</span><span class="p">]</span> <span class="o">=</span> <span class="nx">s</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">endpoints</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="p">(</span><span class="nx">endpoints</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="p">{</span> <span class="na">paths</span><span class="p">:</span> <span class="nx">kept</span> <span class="p">?</span> <span class="nx">paths</span> <span class="p">:</span> <span class="p">[],</span> <span class="nx">endpoints</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Explanation</strong><br /></p>

<ul>
  <li>
    <p>Simulates <strong>R independent trajectories</strong> each lasting n weeks.</p>
  </li>
  <li>
    <p>Each trajectory starts at 0 and adds ±1 depending on whether a breach occurs.</p>
  </li>
  <li>
    <p>Stores a subset of paths (up to “keep”) for visualization.</p>
  </li>
  <li>
    <p>Counts how many simulations end with each possible total S<sub>n</sub>.</p>
  </li>
</ul>

<h3 id="c-binomial-distribution"><strong>c. Binomial Distribution</strong></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">binom</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">k</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">k</span> <span class="o">&gt;</span> <span class="nx">n</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">k</span> <span class="o">===</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">k</span> <span class="o">===</span> <span class="nx">n</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">k</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">n</span> <span class="o">-</span> <span class="nx">k</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">k</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span> <span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="nx">k</span> <span class="o">+</span> <span class="nx">i</span><span class="p">))</span> <span class="o">/</span> <span class="nx">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">binomialPMF</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">pmf</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Float64Array</span><span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">)</span>
        <span class="nx">pmf</span><span class="p">[</span><span class="nx">k</span><span class="p">]</span> <span class="o">=</span> <span class="nx">binom</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="nx">q</span><span class="p">,</span> <span class="nx">k</span><span class="p">)</span> <span class="o">*</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">pow</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nx">q</span><span class="p">,</span> <span class="nx">n</span> <span class="o">-</span> <span class="nx">k</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">pmf</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Explanation</strong><br /></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">binom(n,k)</code> computes the binomial coefficient using a stable multiplicative method.</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">binomialPMF</code> builds a full vector of theoretical probabilities P(K = k) for K ∼ Binomial(n,q).</p>
  </li>
  <li>
    <p>These probabilities are later mapped via S<sub>n</sub> = n − 2k for comparison with the simulated outcomes.</p>
  </li>
</ul>

<h3 id="d-trajectory-plot-random-walk-visualization"><strong>d. Trajectory Plot (Random Walk Visualization)</strong></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">drawPaths</span><span class="p">(</span><span class="nx">paths</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">cssW</span><span class="p">,</span> <span class="nx">cssH</span><span class="p">,</span> <span class="nx">ctx</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">prepCanvas</span><span class="p">(</span><span class="nx">canvas</span><span class="p">,</span> <span class="dl">"</span><span class="s2">paths</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">clearRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">cssW</span><span class="p">,</span> <span class="nx">cssH</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">paths</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>

    <span class="kd">const</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">padL</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span> <span class="nx">padB</span> <span class="o">=</span> <span class="mi">34</span><span class="p">,</span> <span class="nx">padT</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span> <span class="nx">padR</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">W</span> <span class="o">=</span> <span class="nx">cssW</span> <span class="o">-</span> <span class="nx">padL</span> <span class="o">-</span> <span class="nx">padR</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">H</span> <span class="o">=</span> <span class="nx">cssH</span> <span class="o">-</span> <span class="nx">padT</span> <span class="o">-</span> <span class="nx">padB</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">x0</span> <span class="o">=</span> <span class="nx">padL</span><span class="p">,</span> <span class="nx">y0</span> <span class="o">=</span> <span class="nx">cssH</span> <span class="o">-</span> <span class="nx">padB</span><span class="p">;</span>

    <span class="c1">// Find global min/max for vertical scale</span>
    <span class="kd">let</span> <span class="nx">gmin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">gmax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">p</span> <span class="k">of</span> <span class="nx">paths</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">t</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">gmin</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">gmin</span><span class="p">,</span> <span class="nx">p</span><span class="p">[</span><span class="nx">t</span><span class="p">]);</span>
            <span class="nx">gmax</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="nx">gmax</span><span class="p">,</span> <span class="nx">p</span><span class="p">[</span><span class="nx">t</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">gmin</span> <span class="o">===</span> <span class="nx">gmax</span><span class="p">)</span> <span class="p">{</span> <span class="nx">gmin</span><span class="o">--</span><span class="p">;</span> <span class="nx">gmax</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>

    <span class="kd">const</span> <span class="nx">sx</span> <span class="o">=</span> <span class="nx">W</span> <span class="o">/</span> <span class="nx">n</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">sy</span> <span class="o">=</span> <span class="nx">H</span> <span class="o">/</span> <span class="p">(</span><span class="nx">gmax</span> <span class="o">-</span> <span class="nx">gmin</span><span class="p">);</span>

    <span class="c1">// Axes</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">strokeStyle</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">#e2e8f0</span><span class="dl">"</span><span class="p">;</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">lineWidth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">beginPath</span><span class="p">();</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span><span class="nx">x0</span><span class="p">,</span> <span class="nx">y0</span><span class="p">);</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">lineTo</span><span class="p">(</span><span class="nx">x0</span> <span class="o">+</span> <span class="nx">W</span><span class="p">,</span> <span class="nx">y0</span><span class="p">);</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">stroke</span><span class="p">();</span>

    <span class="nx">ctx</span><span class="p">.</span><span class="nx">beginPath</span><span class="p">();</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span><span class="nx">x0</span><span class="p">,</span> <span class="nx">y0</span> <span class="o">-</span> <span class="nx">H</span><span class="p">);</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">lineTo</span><span class="p">(</span><span class="nx">x0</span><span class="p">,</span> <span class="nx">y0</span><span class="p">);</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">stroke</span><span class="p">();</span>

    <span class="c1">// Draw all paths</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">save</span><span class="p">();</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">beginPath</span><span class="p">();</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">rect</span><span class="p">(</span><span class="nx">x0</span><span class="p">,</span> <span class="nx">y0</span> <span class="o">-</span> <span class="nx">H</span><span class="p">,</span> <span class="nx">W</span><span class="p">,</span> <span class="nx">H</span><span class="p">);</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">clip</span><span class="p">();</span>

    <span class="kd">const</span> <span class="nx">xMax</span> <span class="o">=</span> <span class="nx">x0</span> <span class="o">+</span> <span class="nx">W</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">p</span> <span class="k">of</span> <span class="nx">paths</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">grad</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">createLinearGradient</span><span class="p">(</span><span class="nx">x0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">x0</span> <span class="o">+</span> <span class="nx">W</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="nx">grad</span><span class="p">.</span><span class="nx">addColorStop</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="dl">'</span><span class="s1">white</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">grad</span><span class="p">.</span><span class="nx">addColorStop</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">#b5e853</span><span class="dl">'</span><span class="p">);</span>
        <span class="nx">ctx</span><span class="p">.</span><span class="nx">strokeStyle</span> <span class="o">=</span> <span class="nx">grad</span><span class="p">;</span>
        <span class="nx">ctx</span><span class="p">.</span><span class="nx">lineWidth</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>
        <span class="nx">ctx</span><span class="p">.</span><span class="nx">globalAlpha</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">;</span>
        <span class="nx">ctx</span><span class="p">.</span><span class="nx">beginPath</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">t</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">t</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">xMax</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nx">x0</span> <span class="o">+</span> <span class="nx">t</span> <span class="o">*</span> <span class="nx">sx</span><span class="p">);</span>
            <span class="kd">const</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">y0</span> <span class="o">-</span> <span class="p">(</span><span class="nx">p</span><span class="p">[</span><span class="nx">t</span><span class="p">]</span> <span class="o">-</span> <span class="nx">gmin</span><span class="p">)</span> <span class="o">*</span> <span class="nx">sy</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">t</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="k">else</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">lineTo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nx">ctx</span><span class="p">.</span><span class="nx">stroke</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">globalAlpha</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">restore</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Explanation</strong><br /></p>

<ul>
  <li>
    <p>Plots the simulated trajectories on the canvas.</p>
  </li>
  <li>
    <p>The gradient emphasizes direction (white → green).</p>
  </li>
  <li>
    <p>Scaling is automatic and clipped within plot boundaries.</p>
  </li>
  <li>
    <p>The axes correspond to time t and score S<sub>t</sub>.</p>
  </li>
</ul>

<h3 id="e-endpoint-histogram-with-theoretical-curve"><strong>e. Endpoint Histogram with Theoretical Curve</strong></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">drawHistogram</span><span class="p">(</span><span class="nx">endpoints</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">R</span><span class="p">,</span> <span class="nx">pmf</span><span class="p">,</span> <span class="nx">canvas</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">cssW</span><span class="p">,</span> <span class="nx">cssH</span><span class="p">,</span> <span class="nx">ctx</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">prepCanvas</span><span class="p">(</span><span class="nx">canvas</span><span class="p">,</span> <span class="dl">"</span><span class="s2">hist</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">clearRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">cssW</span><span class="p">,</span> <span class="nx">cssH</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">padL</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span> <span class="nx">padB</span> <span class="o">=</span> <span class="mi">34</span><span class="p">,</span> <span class="nx">padT</span> <span class="o">=</span> <span class="mi">14</span><span class="p">,</span> <span class="nx">padR</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">W</span> <span class="o">=</span> <span class="nx">cssW</span> <span class="o">-</span> <span class="nx">padL</span> <span class="o">-</span> <span class="nx">padR</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">H</span> <span class="o">=</span> <span class="nx">cssH</span> <span class="o">-</span> <span class="nx">padT</span> <span class="o">-</span> <span class="nx">padB</span><span class="p">;</span>
    <span class="kd">const</span> <span class="nx">x0</span> <span class="o">=</span> <span class="nx">padL</span><span class="p">,</span> <span class="nx">y0</span> <span class="o">=</span> <span class="nx">cssH</span> <span class="o">-</span> <span class="nx">padB</span><span class="p">;</span>

    <span class="kd">const</span> <span class="nx">scores</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="o">-</span><span class="nx">n</span><span class="p">;</span> <span class="nx">s</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">s</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="nx">scores</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">s</span><span class="p">);</span>

    <span class="kd">const</span> <span class="nx">barW</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="mi">26</span><span class="p">,</span> <span class="nx">W</span> <span class="o">/</span> <span class="p">(</span><span class="nx">scores</span><span class="p">.</span><span class="nx">length</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)));</span>
    <span class="kd">const</span> <span class="nx">xOf</span> <span class="o">=</span> <span class="nx">s</span> <span class="o">=&gt;</span> <span class="nx">x0</span> <span class="o">+</span> <span class="p">((</span><span class="nx">s</span> <span class="o">+</span> <span class="nx">n</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="nx">barW</span><span class="p">;</span>

    <span class="kd">let</span> <span class="nx">maxF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">s</span> <span class="k">of</span> <span class="nx">scores</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">endpoints</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nx">R</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">f</span> <span class="o">&gt;</span> <span class="nx">maxF</span><span class="p">)</span> <span class="nx">maxF</span> <span class="o">=</span> <span class="nx">f</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">yOfFreq</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="nx">y0</span> <span class="o">-</span> <span class="nx">f</span> <span class="o">*</span> <span class="p">(</span><span class="nx">H</span> <span class="o">*</span> <span class="mf">0.95</span> <span class="o">/</span> <span class="nx">maxF</span><span class="p">);</span>

    <span class="c1">// Draw bars</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">#ffffff</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">s</span> <span class="k">of</span> <span class="nx">scores</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">endpoints</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nx">R</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">xOf</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">yOfFreq</span><span class="p">(</span><span class="nx">f</span><span class="p">);</span>
        <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillRect</span><span class="p">(</span><span class="nx">x</span> <span class="o">-</span> <span class="nx">barW</span> <span class="o">*</span> <span class="mf">0.45</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">barW</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">,</span> <span class="nx">y0</span> <span class="o">-</span> <span class="nx">y</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Overlay theoretical curve</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">strokeStyle</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">#b5e853</span><span class="dl">"</span><span class="p">;</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">lineWidth</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">beginPath</span><span class="p">();</span>
    <span class="kd">let</span> <span class="nx">first</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">k</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">prob</span> <span class="o">=</span> <span class="nx">pmf</span><span class="p">[</span><span class="nx">k</span><span class="p">];</span>
        <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">xOf</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nx">y</span> <span class="o">=</span> <span class="nx">yOfFreq</span><span class="p">(</span><span class="nx">prob</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">first</span><span class="p">)</span> <span class="p">{</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span> <span class="nx">first</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span> <span class="p">}</span> <span class="k">else</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">lineTo</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nx">ctx</span><span class="p">.</span><span class="nx">stroke</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Explanation</strong><br /></p>

<ul>
  <li>Computes normalized empirical frequencies of each S<sub>n</sub>.
​</li>
  <li>
    <p>Draws them as vertical bars (white).</p>
  </li>
  <li>
    <p>Theoretical probabilities from Binomial(n, q) are plotted as a smooth green curve.</p>
  </li>
  <li>The comparison shows how empirical results converge to the expected distribution.</li>
</ul>

<h3 id="f-total-variation-distance"><strong>f. Total Variation Distance</strong></h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">totalVariation</span><span class="p">(</span><span class="nx">endpoints</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">R</span><span class="p">,</span> <span class="nx">pmf</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">tv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">k</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">k</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="p">(</span><span class="nx">endpoints</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nx">R</span><span class="p">;</span>
        <span class="nx">tv</span> <span class="o">+=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">abs</span><span class="p">(</span><span class="nx">f</span> <span class="o">-</span> <span class="nx">pmf</span><span class="p">[</span><span class="nx">k</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="nx">tv</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Explanation</strong><br /></p>

<p>Calculates the total variation distance between the empirical and theoretical distributions.<br />
A lower value of this metric indicates that the observed simulation frequencies are closer to the Binomial law.</p>

<hr />

<h2 id="results-and-discussion"><strong>Results and Discussion</strong></h2>

<p>As the number of weeks n and simulation runs R increase:</p>

<ul>
  <li>The empirical mean and variance approach the theoretical values:</li>
</ul>

<div class="formula-box">
E[S<sub>n</sub>​] = n(1 − 2q), &nbsp;&nbsp;&nbsp; Var[S<sub>n</sub>​] = 4nq(1−q)
</div>

<ul>
  <li>
    <p>The histogram becomes smoother and closely fits the Binomial curve.</p>
  </li>
  <li>
    <p>The total variation distance tends to zero, confirming convergence.</p>
  </li>
</ul>

<p>The random-walk visualization highlights how bias in q (the drift) affects the expected direction of S<sub>t</sub>.</p>

<hr />

<h1 id="conclusion"><strong>Conclusion</strong></h1>

<p>This experiment links <strong>cybersecurity event modeling</strong> with <strong>probability theory</strong>.
By simulating weekly outcomes as a biased random walk, we can visualize and quantify convergence toward the <strong>Binomial distribution</strong>.
The interactive web tool effectively demonstrates the relationship between <strong>individual breach probabilities</strong>, <strong>collective attack risk</strong>, and the <strong>law of large numbers</strong>.</p>

<hr />


        © 2025 Simone Di Gregorio — Statistics Course Blog
      </section>
    </div>
  </body>
</html>
